import java.util.*;

import javax.swing.text.html.HTMLDocument.HTMLReader.IsindexAction;

/***
 * 
 * @author jackie
 *
 *         Median is the middle value in an ordered integer list. If the size of
 *         the list is even, there is no middle value. So the median is the mean
 *         of the two middle value.
 * 
 *         Examples: [2,3,4] , the median is 3
 * 
 *         [2,3], the median is (2 + 3) / 2 = 2.5
 * 
 *         Given an array nums, there is a sliding window of size k which is
 *         moving from the very left of the array to the very right. You can
 *         only see the k numbers in the window. Each time the sliding window
 *         moves right by one position. Your job is to output the median array
 *         for each window in the original array.
 * 
 *         For example, Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.
 * 
 *         Window position Median --------------- ----- [1 3 -1] -3 5 3 6 7 1 1
 *         [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3
 *         -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6 Therefore, return the median
 *         sliding window as [1,-1,-1,3,5,6].
 * 
 *         Note: You may assume k is always valid, ie: k is always smaller than
 *         input array's size for non-empty array.
 */

public class Q480_Sliding_Window_Median {
	// 类似题295
	// test case: [1] [k = 1], [2147483647,2147483647] [k = 2],
	// [-2147483648,-2147483648,2147483647,-2147483648,-2147483648,-2147483648,2147483647,2147483647,2147483647,2147483647,-2147483648,2147483647,-2147483648] [k = 3]
	private Integer median = null;
    private Queue<Integer> maxHeap;
    private Queue<Integer> minHeap;
    
    public double[] medianSlidingWindow(int[] nums, int k) {
        if (nums == null || nums.length == 0 || k <= 0)
        {
            return new double[0];
        }
        else if (k > nums.length)
        {
            k = nums.length;
        }
        
        int size = nums.length;
        maxHeap = new PriorityQueue<Integer>();
        minHeap = new PriorityQueue<Integer>();
        double[] result = new double[size-k+1];
        int index = 0;
        
        for (int i = 0; i < size; i++)
        {
            addNum(nums[i]);
            System.out.println();
            System.out.println("**** add num: "+ nums[i]);
            System.out.print("median = "+ median + ", ");
            print(maxHeap, "maxHeap", true);
            print(minHeap, "minHeap", false);
            System.out.println("");
            
            if (i >= k)
            {
            	System.out.println("**** remove num: "+ nums[i-k]);
                removeNum(nums[i-k]);
            }
            
            System.out.print("median = "+ median + ", ");
            print(maxHeap, "maxHeap", true);
            print(minHeap, "minHeap", false);
            System.out.println();
            
            if (i >= k-1)
            {
                result[index++] = getMedian(k);
            }
        }
        
        return result;
    }
    
    private void addNum(int num)
    {
        if (median == null)
        {
            median = num;
            return;
        }
        
        if (num < median)
        {
            maxHeap.offer(-num);
        }
        else
        {
            minHeap.offer(num);
        }
        
        balance();
    }
    
    private void removeNum(int num)
    {
        if (num < median)
        {
            maxHeap.remove(-num);
        }
        else if (num > median)
        {
            minHeap.remove(num);
        }
        else
        {
            median = (maxHeap.size() > minHeap.size()) ? -maxHeap.poll() : minHeap.poll();
        }
        
        balance();
    }
    
    private void balance()
    {
    	if (maxHeap.size() + 1 < minHeap.size())
        {
            maxHeap.offer(-median);
            median = minHeap.poll();
        }
        else if (maxHeap.size() > minHeap.size())
        {
            minHeap.offer(median);
            median = -maxHeap.poll();
        }
    }
    
    private double getMedian(int k)
    {
        if (k % 2 == 1)
        {
            return (double) median;
        }
        else
        {
            int num = (maxHeap.size() > minHeap.size()) ? -maxHeap.peek() : minHeap.peek();
            return (double) ((median+num) / 2.0);
        }
    }

	private void print(Queue<Integer> queue, String name, boolean isMax)
	{
		if (queue.isEmpty())
		{
			System.out.print(name + " = [], ");
		}
		else
		{
			if (isMax)
			{
				System.out.print(name + " size is " + queue.size() + " [" + -queue.peek() + "], ");
			}
			else
			{
				System.out.print(name + " size is " + queue.size() + " [" + queue.peek() + "], ");
			}
		}
	}
	


	/********************************
	 * main function
	 ******************************************/

	public static void main(String[] args) {
		Q480_Sliding_Window_Median t = new Q480_Sliding_Window_Median();
		 int[] nums = {1,3,-1,-3,5,3,6,7};
		// int[] nums = {-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,-1}; Integer.MAX_VALUE
		/***
		 int[] nums = { Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE,
				Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE,
				Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE };
		***/		
				
		// System.out.println(nums.length);
		int k = 3;
		double[] ans = t.medianSlidingWindow(nums, k);

		for (double elem : ans) {
			System.out.print(elem + " ");
		}
	}
}
