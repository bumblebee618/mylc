/***
 * 
 * @author jackie
 * 
 * Given a positive integer n, return the number of the integers in the range [0, n] whose binary representations do not contain consecutive ones.

 

Example 1:

Input: n = 5
Output: 5
Explanation:
Here are the non-negative integers <= 5 with their corresponding binary representations:
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
Among them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. 
Example 2:

Input: n = 1
Output: 2
Example 3:

Input: n = 2
Output: 3
 

Constraints:

1 <= n <= 109
 */
public class Q600_Non_negative_Integers_without_Consecutive_Ones {
	public int findIntegers(int n) {
        int firstOne = 31;
        
        while (firstOne >= 0 && (n & (1 << firstOne)) == 0)
        {
        	firstOne--;
        }
        
        int[][] dp = new int[firstOne+1][2]; 
        dp[0][0] = dp[0][1] = 1;
        
        for (int i = 1; i < dp.length; i++)
        {
        	dp[i][0] = dp[i-1][1] + dp[i-1][0];
        	dp[i][1] = dp[i-1][0];
        }
        
        int result = dp[dp.length-1][0] + dp[dp.length-1][1];
        
        while (firstOne >= 0)
        {
        	if (firstOne > 0 && (n & (1 << firstOne)) == 1)
        	{
        		result -= dp[firstOne-1][1];
        		firstOne--;
        	}	
        	
        	firstOne--;
        }
        
        return result;
    }
	
	
	
	public static void main(String[] args)
	{
		Q600_Non_negative_Integers_without_Consecutive_Ones test = new Q600_Non_negative_Integers_without_Consecutive_Ones();
		System.out.println(test.findIntegers(4));
		System.out.println(test.findIntegers(4));
	}
}
