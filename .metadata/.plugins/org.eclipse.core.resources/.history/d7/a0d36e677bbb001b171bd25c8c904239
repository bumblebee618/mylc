import java.lang.annotation.Target;
import java.util.*;

import javax.print.attribute.standard.NumberUpSupported;

import org.omg.CORBA.Current;





public class Q000_A_Contest 
{	
	public boolean checkZeroOnes(String s) 
    {
        if (s == null || s.length() == 0)
        {
            return false;
        }
        
        int maxOne = 0, maxZero = 0;
        int faster = 0, slower = 0;
        int size = s.length();
        
        while (faster < size)
        {
            slower = faster;
            
            while (faster < size && s.charAt(faster) == s.charAt(slower))
            {
                faster++;
            }
            
            if (s.charAt(slower) == '1')
            {
                maxOne = Math.max(maxOne, faster-slower);
            }
            else
            {
            	maxZero = Math.max(maxZero, faster-slower);
            }
        }
        
        return maxOne > maxZero; 
    }
	
	
	public int minSpeedOnTime(int[] dist, double hour) 
    {
        if (dist == null || dist.length == 0 || hour <= (double) dist.length - 1)
        {
            return -1;
        }
        
        int left = 1, right = 0;
        int size = dist.length;
        
        for (int elem : dist)
        {
        	right = Math.max(right, elem);
        }
        
        if (Math.floor(hour) == size-1)
        {
        	double diff = hour - (double) Math.floor(hour);
        	double tmp = (double) dist[size-1] / diff;
        	right = Math.max(right, (int) Math.ceil(tmp));
        }
        
        if (size - 1 + (dist[size-1] / (double) right) > hour)
        {
        	return -1;
        }
        
        while (left+1 < right)
        {
        	int mid = left + (right - left) / 2;
        	double candidate = search(dist, mid);
        	
        	// System.out.println(left + ", " + right + ", " + mid + ", " + candidate);
        	
        	if (candidate > hour)
        	{
        		left = mid;
        	}
        	else
        	{
        		right = mid;
        	}
        }
        
        return search(dist, left) <= hour ? left : right;
    }
	
	private double search(int[] dist, int speed)
	{
		double time = 0;
		
		for (int i = 0; i < dist.length-1; i++)
		{
			// System.out.println("*: " + dist[i] + ", " + Math.ceil(dist[i] / (double) speed));
			time += Math.ceil(dist[i] / (double) speed);
		}
		
		time += dist[dist.length-1] / (double) speed;
		return time;
	}

	
	
	
	public boolean canReach(String s, int minJump, int maxJump) 
	{
		if (s == null || s.length() <= 1 || s.charAt(s.length()-1) == '1')
		{
			return false;
		}
		
		int curIndex = 0;
		
		Deque<Integer> current = new LinkedList<>();
		current.offer(0);
		
		Deque<Integer> next = new LinkedList<>();
		
		for (int i = minJump; i <= Math.min(maxJump, s.length()-1); i++)
		{
			if (s.charAt(i) == '0')
			{
				next.offer(i);
			}
		}
		
		while (!current.isEmpty())
		{
			int size = 
		}
    }
	
    
    public static void main(String[] args)
    {
    	Q000_A_Contest test = new Q000_A_Contest();
    	
    	/****************************************************/
 
    	int[] dist1 = {1,3,2};
    	double hour1 = 2.7;
    	
    	int[] dist2 = {1,1,100000};
    	double hour2 = 2.01;
    	
    	System.out.println(test.minSpeedOnTime(dist1, hour1));
    	System.out.println(test.minSpeedOnTime(dist2, hour2));
    	
    	
    }
}
