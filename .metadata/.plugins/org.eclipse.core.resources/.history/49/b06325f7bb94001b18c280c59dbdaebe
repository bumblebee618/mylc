import java.util.*;import javax.naming.directory.SearchControls;



public class Q000_A_Contest 
{
	private Map<String, Integer> memo;
	
	public int maxHappyGroups(int batchSize, int[] groups) 
	{
		if (batchSize <= 0 || groups == null || groups.length == 0)
		{
			return 0;
		}
		
		memo = new HashMap<>();
        int[] countMap = new int[batchSize];
        int result = 0, groupSize = 0;
        
        for (int i = 0; i < groups.length; i++)
        {
            int newGroup = groups[i] % batchSize;
            countMap[groups[i] % batchSize]++;
            groupSize += newGroup > 0 ? 1 : 0;
        }
        
        result += countMap[0];
        result += search(0, countMap, groupSize);
        return result;
    }
        
        
    private int search(int curr, int[] countMap, int groupLeft)
    {
        if (groupLeft == 0) 
        {
        	return 0;
        }
        
        String key = Arrays.toString(countMap);
        
        if (memo.containsKey(key)) 
        {
        	return memo.get(key);
        }
        
        int result = 0;
        
		//starting a new batch, current group is happy
        if (curr == 0)
        {
            result++;
            curr = countMap.length;
        }
        
        int count = 0;
        
        for (int i = 1; i < countMap.length; i++)
        {
            if (countMap[i] == 0) 
            {
            	continue;
            }
            
            countMap[i]--;
            
			//number of remaining group - 1
            int curLeft = groupLeft - 1;
            
			//how much left in the batch
            int nextcurr = curr - i;
            
			// not enough, add n (this was my bug during the contest)
            if (nextcurr < 0) 
            {
            	nextcurr += countMap.length;
            }
            
            count = Math.max(count, search(nextcurr, countMap, curLeft));
            countMap[i]++;
        }
        
        result += count;
        memo.put(key, result);
        return result;
    }
	
	
	/***
	private Map<Integer, int[]> memo;
	private int[] countMap;
	private int count = 0;
	
	public int maxHappyGroups(int batchSize, int[] groups) 
    {
		if (batchSize <= 0 || groups == null || groups.length == 0)
		{
			return 0;
		}
		
		memo = new HashMap<>();
		countMap = new int[batchSize];
		int candidateSize = 0;
		List<Integer> list = new ArrayList<>();
		
		for (int group : groups)
		{
			countMap[group % batchSize]++;
		}
		
		count += countMap[0];
		
		for (int i = 1; i < batchSize; i++)
		{
			for (int j = 0; j < countMap[i]; j++)
			{
				list.add(i);
			}
		}
		
		Map<Integer, Integer>[] status = new Map[list.size()+1];
		status[0] = new HashMap<>();
		status[0].put(0, 0);
		memo.put(0, new int[batchSize]);
		
		for (int i = 1; i <= candidateSize; i++)
		{
			status[i] = new HashMap<>();
			
			for (Map.Entry<Integer, Integer> entry : status[i-1].entrySet())
			{
				int prevStatus = entry.getKey();
				int prevSum = entry.getValue();
				int[] prevSolution = memo.get(prevStatus);
				
				if (!checkOrUpdate(prevSolution, countMap, true))
				{
					continue;
				}
				
				for (int index = 0; index < list.size() && prevSum+list.get(index) <= batchSize; index++)
				{
					if ( (prevStatus & (1 << index)) == 0 )
					{
						int num = list.get(index);
						
						if (countMap[num] >= prevSolution[num] + 1)
						{
							status[i].put( (prevStatus | (1 << index)), prevSum + num);
							
							int[] curSolution = Arrays.copyOf(prevSolution, prevSolution.length);
							curSolution[num]++;
							memo.put( (prevStatus | (1 << index)), curSolution);
							
							if (prevSum + num == batchSize && checkOrUpdate(prevSolution, countMap, true))
							{
								checkOrUpdate(prevSolution, countMap, false);
							}
						}
					}
				}
				
				
			}
			
		}
    }
	
	private boolean checkOrUpdate(int[] solution, int[] map, boolean check)
	{
		for (int i = 0; i < map.length; i++)
		{
			if (solution[i] > map[i])
			{
				return false;
			}
			
			map[i] -= check ? 0 : solution[i];
		}
		
		return true;
	}
	
	***/
	
	
	
	
	
    public static void main(String[] args)
    {
    	Q000_A_Contest test = new Q000_A_Contest();
    	
    	/****************************************************/
    	
    	int[] groups1 = {1,2,3,4,5,6};
    	int batchSize1 = 3;
    	
    	int[] groups2 = {1,3,2,5,2,2,1,6};
    	int batchSize2 = 4;
    	
    	int[] groups3 = {369821235,311690424,74641571,179819879,171396603,274036220};
    	int batchSize3 = 3;
    	
    	int[] groups4 = {844438225,657615828,355556135,491931377,644089602,30037905,863899906,246536524,682224520};
    	int batchSize4 = 3;
    	
    	int[] groups5 = {369205928,981877451,947462486,899465743,737778942,573732515,520226542,824581298,571789442,251943251,70139785,778962318,43379662,90924712,142825931,182207697,178834435,978165687};
    	int batchSize5 = 6;
    	
    	int[] groups6 = {287773481,815094798,356732984,644469322,543193620,903158817,274116865,395252956,363839119,365378492,122313059,312690039,252532812};
    	int batchSize6 = 7;
    	
    	/***
    	System.out.println("*" + test.maxHappyGroups(batchSize1, groups1));
    	
    	System.out.println("*" + test.maxHappyGroups(batchSize2, groups2));
    	
    	System.out.println("*" + test.maxHappyGroups(batchSize3, groups3));
    	
    	System.out.println("*" + test.maxHappyGroups(batchSize4, groups4));
    	
    	System.out.println("*" + test.maxHappyGroups(batchSize5, groups5));
    	***/
    	
    	System.out.println("*" + test.maxHappyGroups(batchSize6, groups6));
    }
}
