import java.util.*;
import java.util.Map.Entry;

public class Q000_A_Contest 
{
	public int minElements(int[] nums, int limit, int goal) 
    {
        if (nums == null || nums.length == 0)
        {
            return 0;
        }
        
        long sum = Arrays.stream(nums).sum();
        long diff = Math.abs(sum - goal);
        long step = (diff-1) / limit + 1;
        return (int) step;
    }
	
	
	
	private Set<Integer>[] graph;
    private int[] dist;
    private int result = 0;
    
    public int countRestrictedPaths(int n, int[][] edges) 
    {
        if (edges == null || edges.length == 0 || edges[0].length != 3 || n <= 0)
        {
            return 0;
        }
        
        graph = new Set[n+1];
        
        for (int i = 0; i < graph.length; i++)
        {
            graph[i] = new HashSet<>();
        }
        
        int[][] weights = new int[n+1][n+1];
        
        for (int[] edge : edges)
        {
            weights[edge[0]][edge[1]] = edge[2];
            weights[edge[1]][edge[0]] = edge[2];
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        
        dist = new int[n+1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[n] = 0;
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(n);
        
        // bfs
        while (!queue.isEmpty())
        {
            int size = queue.size();
            
            for (int i = 0; i < size; i++)
            {
                int node = queue.poll();
                
                for (int next : graph[node])
                {
                    if (dist[next] > dist[node] + weights[node][next])
                    {
                        dist[next] = dist[node] + weights[node][next];
                        queue.offer(next);
                    }
                }
            }
        }
        
        // dfs
        dfs(1, n);
        return result;
    }
    
    private void dfs(int start, int end)
    {
        if (start == end)
        {
            result++;
            return;
        }
        
        for (int next : graph[start])
        {
            if (next < start)
            {
                // graph[start].remove(next);
            	continue;
            }
            else if (dist[start] <= dist[next])
            {
                continue;
            }
            else
            {
                dfs(next, end);
            }
        }
    }
	
	
	
    public static void main(String[] args)
    {
    	Q000_A_Contest test = new Q000_A_Contest();
    	
    	int n1 = 5;
    	int[][] edges1 = {{1,2,3},{1,3,3},{2,3,1},{1,4,2},{5,2,2},{3,5,1},{5,4,10}};
    	
    	System.out.println(test.countRestrictedPaths(n1, edges1));
    	
    	
    	/***
    	int[] nums1 = {1,-1,1};
    	int limit1 = 3;
    	int goal1 = -4;
    	
    	int[] nums2 = {1,-10,9,1};
    	int limit2 = 100;
    	int goal2 = 0;
    	
    	int[] nums3 = {3,6,4,2,5,5};
    	int limit3 = 6;
    	int goal3 = 881574077;
    	
    	int[] nums4 = {1000000,1000000,1000000,1000000,1000000,1000000,1000000};
    	int limit4 = 1000000;
    	int goal4 = 1000000_000;
    	
    	System.out.println(test.minElements(nums1, limit1, goal1));
    	System.out.println(test.minElements(nums2, limit2, goal2));
    	System.out.println(test.minElements(nums3, limit3, goal3));
    	System.out.println(test.minElements(nums4, limit4, goal4));
    	***/
    }
    
}
