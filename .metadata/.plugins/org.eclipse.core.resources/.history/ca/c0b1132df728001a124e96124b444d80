/***
 * 
 * @author jackie
 * 
 * In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.

Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.

Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.

Example:

Input: [1,2,1,2,6,7,5,1], 2
Output: [0, 3, 5]
Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].
We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.
 

Note:

nums.length will be between 1 and 20000.
nums[i] will be between 1 and 65535.
k will be between 1 and floor(nums.length / 3).
 */
public class Q689_Maximum_Sum_of_3_Non_Overlapping_Subarrays {
	public int[] maxSumOfThreeSubarrays(int[] nums, int k) 
	{
		if (nums == null || nums.length < k*3)
		{
			return new int[0];
		}
		
		int len = nums.length;
        int sum[] = new int[len+1];
        
        for (int i = 1; i <= len; i++) 
        {
            sum[i] = nums[i-1] + sum[i-1];
        }

        int[][] dp  = new int[len+1][4];
        int[][] from = new int[len+1][4];
        from[0][3] = -1;
        int[] result = new int[3];
        
        for (int i = 1; i < 4; i++) 
        {
            for (int j = 1; j <= len; j++) 
            {
                if (j >= k) 
                {
                	if (dp[j-1][i] < dp[j-k][i-1] + sum[j]-sum[j-k])
                	{
                		dp[j][i] = dp[j-k][i-1] + sum[j]-sum[j-k];
                		from[j][i] = j-k;
                	}
                	else
                	{
                		dp[j][i] = dp[j-1][i];
                		from[j][i] = from[j-1][i];
                	}
                }
            }
        }
        
        for (int i = 0; i <= len; i++) 
        {
        	System.out.print(sum[i] + ",");
        }
        System.out.println();
        System.out.println();
        
        for (int i = 0; i < 4; i++) 
        {
            for (int j = 0; j <= len; j++) 
            {
            	System.out.print(from[j][i] + ",");
            }
            System.out.println();
        }
        
        System.out.println();
        System.out.println();
        
        for (int i = 0; i < 4; i++) 
        {
            for (int j = 0; j <= len; j++) 
            {
            	System.out.print(dp[j][i] + ",");
            }
            System.out.println();
        }

        // Retrieve the index result.
        int start = from[len][3];
        int index = 2;
        
        while (index >= 0)
        {
        	result[index--] = start;
        	start = from[index][3];
        } 
        
        /***
        while (num > 0) {
            if (dp[j][num] > dp[j-1][num]) 
            {
                result[num-1] = j-k;
                num--;
                j--;
            }
        }
        ***/

        return result;
	}
	
	class State
	{
		public int maxSum;
		public int preIndex;
		
		public State(int sum, int index)
		{
			maxSum = sum;
			preIndex = index;
		}
	}
	
	
	public static void main(String[] args)
	{
		Q689_Maximum_Sum_of_3_Non_Overlapping_Subarrays test = new Q689_Maximum_Sum_of_3_Non_Overlapping_Subarrays();
		int[] nums = {1,2,1,2,6,7,5,1};
		test.maxSumOfThreeSubarrays(nums, 2);
	}
}
