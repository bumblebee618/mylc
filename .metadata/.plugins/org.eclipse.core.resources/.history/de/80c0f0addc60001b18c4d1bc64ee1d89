import java.util.Stack;

/***
 * 
 * @author jackie
 * 
 * If the depth of a tree is smaller than 5, then this tree can be represented by a list of three-digits integers.
For each integer in this list:
	1. The hundreds digit represents the depth D of this node, 1 <= D <= 4.
	2. The tens digit represents the position P of this node in the level it belongs to, 1 <= P <= 8. The position is the same as that in a full binary tree.
	3. The units digit represents the value V of this node, 0 <= V <= 9.
Given a list of ascending three-digits integers representing a binary tree with the depth smaller than 5, you need to return the sum of all paths from the root towards the leaves.
It's guaranteed that the given list represents a valid connected binary tree.
Example 1:
Input: [113, 215, 221]
Output: 12
Explanation: 
The tree that the list represents is:
    3
   / \
  5   1
The path sum is (3 + 5) + (3 + 1) = 12.
 
Example 2:
Input: [113, 221]
Output: 4
Explanation: 
The tree that the list represents is: 
    3
     \
      1
The path sum is (3 + 1) = 4.

 */
public class Q666_Path_Sum_IV 
{
	public int pathSum(int[] nums) 
    {
        if (nums == null || nums.length == 0)
        {
            return 0;
        }
        
        int[][] tree = new int[5][9];
        
        for (int num : nums)
        {
            int row = num / 100;
            int col = (num / 10) - row * 10;
            int value = num % 10;
            tree[row][col] = value;
        }
        
        Stack<int[]> stack = new Stack<>();
        stack.push(new int[] {1, 1});
        int result = 0;
        
        while (!stack.isEmpty())
        {
            int[] node = stack.pop();
            result += tree[node[0]][node[1]];
            
            int leftCol = (1 << node[0]) - 1;
            int rightCol = 1 << node[0];
            
            if (node[0]+1 < tree.length && leftCol < tree[0].length)
            {
                stack.push(new int[] {node[0]+1, leftCol}); 
            }
            
            if (node[0]+1 < tree.length && rightCol < tree[0].length)
            {
                stack.push(new int[] {node[0]+1, rightCol}); 
            }
        }
        
        return result;
    }

	
	
	public static void main(String[] args)
	{
		Q666_Path_Sum_IV test = new Q666_Path_Sum_IV();
		int[] nums = {113, 215, 221};
		System.out.println(test.pathSum(nums));
	}
}
