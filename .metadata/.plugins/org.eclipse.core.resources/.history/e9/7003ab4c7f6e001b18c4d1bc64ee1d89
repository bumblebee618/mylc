import java.util.*;

public class Q000_Minimum_Degree_of_a_Connected_Trio_in_a_Graph {
	public int minTrioDegree(int n, int[][] edges) 
    {
        if (n <= 0 || edges == null || edges.length == 0 || edges[0].length != 2)
        {
            return 0;
        }
        
        Set<Integer>[] graph = new Set[n+1];
        
        for (int i = 1; i <= n; i++)
        {
            graph[i] = new HashSet<>();
        }
        
        for (int[] edge : edges)
        {
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        
        Map<Integer, Set<Integer>> trios = new HashMap<>();
        
        for (int i = 1; i <= n; i++)
        {
            Set<Integer> visited = new HashSet<>();
            visited.add(i);
            dfs(graph, visited, i, i, 1, trios, new HashSet<Integer>());
        }
        
        System.out.println(trios.size());
        
        int result = Integer.MAX_VALUE;
        
        for (Map.Entry<Integer, Set<Integer>> entry : trios.entrySet())
        {
            int degree = 0;
            Set<Integer> trio = entry.getValue();
            
            for (int node : trio)
            {
                for (int next : graph[node])
                {
                    degree += !trio.contains(next) ? 1 : 0;
                }
            }
            
            result = Math.min(result, degree);
        }
        
        return result;
    }
    
    private void dfs(
        Set<Integer>[] graph, 
        Set<Integer> visited, 
        int startNode, 
        int curNode, 
        int level,
        Map<Integer, Set<Integer>> trios,
        Set<Integer> path)
    {        
        path.add(curNode);
        
        for (int next : graph[curNode])
        {
            if (level < 3)
            {
                if (!visited.contains(next))
                {
                    visited.add(next);
                    dfs(graph, visited, startNode, next, level+1, trios, path);
                }
            }
            else
            {
                if (next == startNode && path.size() == 3)
                {
                	System.out.print("next=" + next + "; ");
                	
                    int id = 0;
                    
                    for (int node : path)
                    {
                    	System.out.print(node + ", ");
                        id += node;
                    }
                    
                    System.out.println("id = " + id);
                    
                    trios.put(id, new HashSet<>(path));
                }
            }
        }
        
        path.remove(path.size()-1);
    }
    
    
    
    
    
    public static void main(String[] args)
    {
    	Q000_Minimum_Degree_of_a_Connected_Trio_in_a_Graph test = new Q000_Minimum_Degree_of_a_Connected_Trio_in_a_Graph();
    	int[][] edges = {{1,2},{1,3},{3,2},{4,1},{5,2},{3,6}};
    	int[][] edges2 = {{1,3},{4,1},{4,3},{2,5},{5,6},{6,7},{7,5},{2,6}};
    	int n2 = 7;
    	int[][] edges3 = {{6,5},{4,3},{5,1},{1,4},{2,3},{4,5},{2,6},{1,3}};
    	int n3 = 6;
    	System.out.println(test.minTrioDegree(n2, edges2));
    }
}
