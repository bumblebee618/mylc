import java.util.*;



public class Q000_A_Contest 
{	
	public String replaceDigits(String s) 
    {
        if (s == null || s.length() <= 1)
        {
            return s;
        }
        
        char[] letters = s.toCharArray();
        
        for (int i = 0; i+1 < letters.length; i += 2)
        {
            letters[i+1] = (char) (letters[i] + (letters[i+1] - '0'));
        }
        
        return new String(letters);
    }
	
	private Queue<Integer> seats;
    private Set<Integer> visited;

    
    
    public int reserve() 
    {
        if (seats.size() == 0)
        {
            return -1;
        }
        
        int seat = seats.poll();
        visited.add(seat);
        return seat;
    }
    
    public void unreserve(int seatNumber) 
    {
        if (!visited.contains(seatNumber))
        {
            return;
        }
        
        visited.remove(seatNumber);
        seats.add(seatNumber);
    }
	
    
    
    public int maximumElementAfterDecrementingAndRearranging(int[] arr) 
    {
        if (arr == null || arr.length == 0)
        {
            return -1;
        }
        
        Queue<Integer> heap = new PriorityQueue<>();
        int oneNum = 0, result = 1, size = arr.length;
        
        for (int num : arr)
        {
            if (num == 1)
            {
                oneNum++;
            }
            else
            {
                heap.offer(num);
            }
        }
        
        int left = 1, right = size;
        int prevLeft = 1, prevRight = -1;
        
        if (oneNum == 0)
        {
            heap.poll();
        }
        
        if (oneNum > 1)
        {
            right = size-1 - (oneNum-2);
            prevRight = 1;
        }
        
        int index = 0;
        
      //   System.out.println(left + "," + right);
        
        while (left < right)
        {
            int candidate = heap.poll();
            
            if (right == size)
            {
                int num = Math.min(candidate, prevLeft+1);
                prevLeft = num;
                result = Math.max(result, num);
                left++;
            }
            else
            {
                if (index % 2 == 0)
                {
                    int leftNum = Math.min(candidate, prevLeft+1);
                    prevLeft = leftNum;
                    result = Math.max(result, leftNum);
                    left++;
                }
                else
                {
                    int rightNum = Math.min(candidate, prevRight+1);
                    prevRight = rightNum;
                    result = Math.max(result, rightNum);
                    right--;
                }
            }
            
            index++;
        }
        
        return result;
    }
	
    
    
    public int[] closestRoom(int[][] rooms, int[][] queries) 
    {
        if (rooms == null || rooms.length == 0 || rooms[0].length != 2 || queries == null || queries.length == 0 || queries[0].length != 2)
        {
            return new int[0];
        }
        
        int[] result = new int[queries.length];
        TreeMap<Integer, Integer> treeMap = new TreeMap<>();
        
        for (int[] room : rooms)
        {
        	treeMap.put(room[0], room[1]);
        }
        
        for (int i = 0; i < queries.length; i++)
        {
            int leftIndex = findIndex(treeMap, queries[i][0], queries[i][1], true);
            int rightIndex = findIndex(treeMap, queries[i][0], queries[i][1], false);
            
            System.out.println(i + ": " + leftIndex + ", " + rightIndex);
            
            if (leftIndex != -1 && rightIndex != -1)
            {
                result[i] = (queries[i][0] - leftIndex) <= (rightIndex - queries[i][0]) ? leftIndex : rightIndex;
            }
            else if (leftIndex != -1)
            {
                result[i] = leftIndex;
            }
            else if (rightIndex != -1)
            {
                result[i] = rightIndex;
            }
            else
            {
                result[i] = -1;
            }
        }
        
        return result;
    }
    
    private int findIndex(
    		TreeMap<Integer, Integer> treeMap, 
    		int start, 
    		int minSize, 
    		boolean isLeft)
    {
    	if (treeMap.getOrDefault(start, 0) > 0 && treeMap.get(start) >= minSize)
    	{
    		return start;
    	}
    	
    	int step = isLeft ? -1 : 1;
    	Integer nextKey = start + step;
    	
    	while (nextKey != null)
        {
        	Map.Entry<Integer, Integer> entry = isLeft 
        			? treeMap.floorEntry(nextKey) 
        			: treeMap.ceilingEntry(nextKey);
        	
        	if (entry != null && entry.getValue() >= minSize)
        	{
        		return entry.getKey();
        	}
        	
        	nextKey = (entry == null) ? null : entry.getKey() + step;
        }
        
        return -1;
    }
    
    
    
    public static void main(String[] args)
    {
    	Q000_A_Contest test = new Q000_A_Contest();
    	
    	/****************************************************/
 
    	int[][] rooms1 = {{2,2},{1,2},{3,2}};
    	int[][] queries1 = {{3,1},{3,3},{5,2}};
    	
    	int[][] rooms2 = {{1,4},{2,3},{3,5},{4,1},{5,2}};
    	int[][] queries2 = {{2,3},{2,4},{2,5}};
    	
    	int[][] rooms3 = {{23,22},{6,20},{15,6},{22,19},{2,10},{21,4},{10,18},{16,1},{12,7},{5,22}};
    	int[][] queries3 = {{12,5},{15,15},{21,6},{15,1},{23,4},{15,11},{1,24},{3,19},{25,8},{18,6}};
    	
    	
    	int[] result3 = test.closestRoom(rooms3, queries3);
    	
    	for (int num : result3)
    	{
    		System.out.print(num + ", ");
    	}
    	System.out.println();

    	
    	
    }
}
