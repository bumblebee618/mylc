import java.util.*;

public class Q000_Contest {
	public int minOperations(int[] nums1, int[] nums2) 
    {
        if (nums1 == null || nums1.length == 0 
        	|| nums2 == null || nums2.length == 0)
        {
            return -1;
        }
        
        int size1 = nums1.length, size2 = nums2.length;
        int max1 = size1 * 6, min1 = size1;
        int max2 = size2 * 6, min2 = size2;
        
        int sum1 = Arrays.stream(nums1).sum();
        int sum2 = Arrays.stream(nums2).sum(); 
        
        if (max1 < min2 || max2 < min1)
        {
            return -1;
        }
        else if (sum1 == sum2)
        {
            return 0;
        }
        
        int diff = Math.abs(sum1 - sum2);
        
        int[] minArray = sum1 < sum2 ? nums1 : nums2;
        int[] maxArray = sum1 < sum2 ? nums2 : nums1;
        Arrays.sort(minArray);
        Arrays.sort(maxArray);
        
        int index1 = 0, index2 = maxArray.length-1;
        int step = 0;
        
        while (diff > 0)
        {
            step++;
            
            if ((index1 < minArray.length && diff <= 6-minArray[index1]) 
                || (index2 >= 0 && diff < maxArray[index2]-1))
            {
                break;
            }
            
            if (index1 < minArray.length && index2 >= 0)
            {
                if (6-minArray[index1] > maxArray[index2]-1)
                {
                    diff -= 6-minArray[index1++];
                }
                else
                {
                    diff -= maxArray[index2--]-1;
                }
            }
            else if (index2 >= 0)
            {
                diff -= maxArray[index2--]-1;
            }
            else
            {
                diff -= 6-minArray[index1++];
            }
        }
        
        return step;
    }
	
	
	
	
	private int gap = Integer.MAX_VALUE;
    private int resultPrice = 0;
    // private Map<String, Integer> memo = new HashMap<>();
    private int target = 0;
    
    public int closestCost(int[] baseCosts, int[] toppingCosts, int target) 
    {
        if (baseCosts == null || baseCosts.length == 0 
            || toppingCosts == null || toppingCosts.length == 0 || target <= 0)
        {
            return 0;
        }
        
        this.target = target;
        Arrays.sort(toppingCosts);
        
        for (int base : baseCosts)
        {
            if (base == target)
            {
                return target;        
            }
            
            boolean[] visited = new boolean[toppingCosts.length];
            search(toppingCosts, 0, visited, base);
        }
        
        return resultPrice;
    }
    
    private void search(int[] toppingCosts, int start, boolean[] visited, int price)
    {
    	if (gap > Math.abs(price - target) 
           || (gap == Math.abs(price - target) && price < resultPrice))
        {
    		gap = Math.abs(price - target);
            resultPrice = price;
        }
    	
    	if (price > target)
    	{
    		return;
    	}
        
        for (int i = start; i < toppingCosts.length; i++)
        {
            if (visited[i])
            {
                continue;
            }
            
            visited[i] = true;
            
            for (int j = 1; j <= 2; j++)
            {
                int curPrice = price + toppingCosts[i] * j;
                search(toppingCosts, i, visited, curPrice);
            }
            
            visited[i] = false;
        }
    }
    
    
    /***
     *     	
        if (gap > Math.abs(price - target) 
            || (gap == Math.abs(price - target) && price < resultPrice))
        {
            gap = Math.abs(price - target);
            resultPrice = price;
        }
     * @param args
     */
    
    public double[] getCollisionTimes(int[][] cars) 
    {
        if (cars == null || cars.length == 0 || cars[0].length == 0)
        {
            return new double[0];
        }
        
        int size = cars.length;
        double[] result = new double[size];
        result[size-1] = -1;
        int capSpeed = cars[size-1][1];
        
        for (int i = size-2; i >= 0; i--)
        {
            if (cars[i][1] <= capSpeed)
            {
            	System.out.println("1：i = " + i + ", capSpeed: " + capSpeed);
                result[i] = -1;
                capSpeed = cars[i][1];
            }
            else
            {
            	System.out.println("2：i = " + i + ", capSpeed: " + capSpeed);
            	if (cars[i][1] > cars[i+1][1])
            	{
            		double hour = (cars[i+1][0] - cars[i][0]) * 1.0 / (cars[i][1] - cars[i+1][1]);
            		
            		System.out.println(i + ": " + hour);
            		
            		if (hour <= result[i+1])
            		{
            			result[i] = hour;
            			continue;
            		}
            	}
            	
            	double hoursBeforeCollide = (result[i+1] == -1) ? 0 : result[i+1];
                double totalDist = (cars[i+1][1] - cars[i][1]) * hoursBeforeCollide + (cars[i+1][0] - cars[i][0]);
                result[i] = totalDist / (cars[i][0] - capSpeed);
            }
        }
        
        return result;
    }
    
    
    public static void main(String[] args)
    {
    	Q000_Contest test = new Q000_Contest();
    	int[] baseCosts = {4};
    	int[] toppingCosts = {9};
    	int target = 9;
    	
    	int[] baseCosts2 = {1,7};
    	int[] toppingCosts2 = {3,4};
    	int target2 = 10;
    	
    	
    	// System.out.println(test.closestCost(baseCosts2, toppingCosts2, target2));
    	
    	
    	int[] nums1_1 = {1,2,3,4,5,6};
    	int[] nums2_1 = {1,1,2,2,2,2};
    	
    	int[] nums1_2 = {1,1,1,1,1,1,1};
    	int[] nums2_2 = {6};
    	
    	int[] nums1_3 = {6,6};
    	int[] nums2_3 = {1};
    	
    	// System.out.println(test.minOperations(nums1_1, nums2_1));
    	// System.out.println(test.minOperations(nums1_2, nums2_2));
    	// System.out.println(test.minOperations(nums1_3, nums2_3));
    	
    	int[][] cars = {{1,2},{2,1},{4,3},{7,2}};
    	double[] result = test.getCollisionTimes(cars);
    	
    	for (double time : result)
    	{
    		System.out.print(time + ", ");
    	}
    }
    
}
