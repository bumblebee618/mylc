import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

import Exception.NotFullPaidException;
import Exception.NotSufficientChangeException;
import Exception.SoldOutException;

public class VendingMachineImpl implements VendingMachine 
{   
    private Inventory<Coin> cashInventory = new Inventory<Coin>();
    private Inventory<Item> itemInventory = new Inventory<Item>();  
    private long totalSales;
    private Item currentItem;
    private long currentBalance; 
   
    public VendingMachineImpl()
    {
        initialize();
    }
   
    private void initialize()
    {       
        //initialize machine with 5 coins of each denomination and 5 cans of each Item       
        for (Coin coin : Coin.values())
        {
            cashInventory.put(coin, 5);
        }
       
        for(Item item : Item.values())
        {
            itemInventory.put(item, 5);
        }
    }
   
   @Override
   public long selectItemAndGetPrice(Item item) throws SoldOutException
   {
        if (!itemInventory.hasItem(item))
        {
            return item.getPrice();
        }
        else
        {
        	throw new SoldOutException("Sold Out, Please buy another item");
        }
    }

    @Override
    public void insertCoin(Coin coin) 
    {
        currentBalance = currentBalance + coin.getDenomination();
        cashInventory.add(coin);
    }

    @Override
    public Bucket<Item, List<Coin>> collectItemAndChange() 
    {
        Item item = collectItem();
        totalSales = totalSales + currentItem.getPrice();
        List<Coin> change = collectChange();
        return new Bucket<Item, List<Coin>>(item, change);
    }
       
    private Item collectItem() throws NotSufficientChangeException, NotFullPaidException
    {
    	if (!isFullPaid())
    	{
    		long remainingBalance = currentItem.getPrice() - currentBalance;
            throw new NotFullPaidException("Price not full paid, remaining : ", remainingBalance);
    	}
    	
    	if (!hasSufficientChange())
        {
        	throw new NotSufficientChangeException("Not Sufficient change in Inventory");
        }           
        
        itemInventory.deduct(currentItem);
        return currentItem;
    }
   
    private List<Coin> collectChange() 
    {
        long changeAmount = currentBalance - currentItem.getPrice();
        List<Coin> change = getChange(changeAmount);
        updateCashInventory(change);
        currentBalance = 0;
        currentItem = null;
        return change;
    }
   
    @Override
    public List<Coin> refund()
    {
        List<Coin> refund = getChange(currentBalance);
        updateCashInventory(refund);
        currentBalance = 0;
        currentItem = null;
        return refund;
    }
   
    private boolean isFullPaid() 
    {
    	return (currentBalance >= currentItem.getPrice()) ? true : false;
    }

    private List<Coin> getChange(long amount) throws NotSufficientChangeException
    {
        List<Coin> changes = new LinkedList<>();
        
        if (amount <= 0)
        {
        	return changes;
        }
        
        long balance = amount;
        
        while (balance > 0)
        {
            if (balance >= Coin.QUARTER.getDenomination() && cashInventory.hasItem(Coin.QUARTER))
            {
                changes.add(Coin.QUARTER);
                balance = balance - Coin.QUARTER.getDenomination();
            }
            else if (balance >= Coin.DIME.getDenomination() && cashInventory.hasItem(Coin.DIME)) 
            {
                changes.add(Coin.DIME);
                balance = balance - Coin.DIME.getDenomination();
            }
            else if (balance >= Coin.NICKLE.getDenomination() && cashInventory.hasItem(Coin.NICKLE)) 
            {
                changes.add(Coin.NICKLE);
                balance = balance - Coin.NICKLE.getDenomination();
            }
            else if (balance >= Coin.PENNY.getDenomination() && cashInventory.hasItem(Coin.PENNY)) 
            {
                changes.add(Coin.PENNY);
                balance = balance - Coin.PENNY.getDenomination();
            }
            else
            {
                throw new NotSufficientChangeException("NotSufficientChange, Please try another product");
            }
        }
       
        return changes;
    }
   
    @Override
    public void reset()
    {
        cashInventory.clear();
        itemInventory.clear();
        totalSales = 0;
        currentItem = null;
        currentBalance = 0;
    } 
  
    private boolean hasSufficientChange()
    {
        return hasSufficientChangeForAmount(currentBalance - currentItem.getPrice());
    }
   
    private boolean hasSufficientChangeForAmount(long amount)
    {
        boolean hasChange = true;
        
        try
        {
            getChange(amount);
        }
        catch (NotSufficientChangeException nsce)
        {
            return hasChange = false;
        }
       
        return hasChange;
    }

    private void updateCashInventory(List<Coin> change) 
    {
        for (Coin c : change)
        {
            cashInventory.deduct(c);
        }
    }
   
    public long getTotalSales()
    {
        return totalSales;
    }
   
    public void printStats()
    {
        System.out.println("Total Sales : " + totalSales);
        System.out.println("Current Item Inventory : " + itemInventory);
        System.out.println("Current Cash Inventory : " + cashInventory);
    } 
}


