import java.util.*;

import Q124_Binary_Tree_Maximum_Path_Sum.resultTuple;




public class Q000_A_Contest 
{	
	public int getMinDistance(int[] nums, int target, int start) 
    {
        if (nums == null || nums.length == 0 || start < 0 || start >= nums.length)
        {
            return -1;
        }
        
        int left = start, right = start;
        int size = nums.length;
        int step = 0;
        
        while (left >= 0 || right < size)
        {
            if (left >= 0 && nums[left] == target)
            {
                return step;
            }
            else if (right < size && nums[right] == target)
            {
                return step;
            }
            
            if (left >= 0)
            {
                left--;
            }
            
            if (right < size)
            {
                right++;
            }
            
            step++;
        }
        
        return -1;
    }
	
	// private Integer[][] memo;
	
	public boolean splitString(String s) 
    {
        if (s == null || s.length() == 0)
        {
        	return true;
        }
        
        int size = s.length();
        long[][] memo = new long[size][size];
        
        for (int i = 0; i < size; i++)
        {
        	for (int j = i; j < size; j++)
        	{
        		String str = s.substring(i, j+1);
        		
        		try 
        		{
        			long num = Long.parseLong(str);
        			memo[i][j] = num;
        		}
        		catch (Exception e)
        		{
        			
        		}
        	}
        }
        
        return backtrack(memo, -1, 0, 0);
    }
	
	private boolean backtrack(long[][] memo, long prevNum, int start, int len)
	{
		if (start == memo.length)
		{
			return len > 1;
		}
		
		for (int end = start; end < memo.length; end++)
		{
			if (prevNum == -1 || memo[start][end] == prevNum - 1)
			{
				if (backtrack(memo, memo[start][end], end+1, len+1))
				{
					return true;
				}
			}
		}
		
		return false;
	}
	
	
	
	
	
	
	public int getMinSwaps(String num, int k)
	{
		char[] originDigits = num.toCharArray();
		char[] digits = num.toCharArray();
		
		for (int i = 0; i < k; i++)
		{
			nextPermutation(digits);
		}
		
		int start = 0, size = digits.length;
		int step = 0;
		
		while (start < size)
		{
			if (digits[start] != originDigits[start])
			{
				// System.out.println(start);
				// System.out.println(findTarget(digits, originDigits[start], start));
				
				step += findTarget(digits, originDigits[start], start);
			}
			
			start++;
		}
		
		return step;
	}
	
	private int findTarget(char[] digits, char target, int start)
	{
		int end = start;
		
		while (end < digits.length && digits[end] != target)
		{
			end++;
		}
		
		for (int i = end; i-1 >= start; i--)
		{
			char tmp = digits[i];
			digits[i] = digits[i-1];
			digits[i-1] = tmp;
		}
		
		return end-start;
	}
	
	private void nextPermutation(char[] nums) 
    {
        if (nums == null || nums.length == 0)
        {
            return;
        }
        
        int size = nums.length;
        int index1 = size - 2;
        
        while (index1 >= 0 && nums[index1] >= nums[index1+1])
        {
            index1--;
        }
        
        if (index1 >= 0)
        {
            int index2 = size-1;
            
            while (nums[index2] <= nums[index1])
            {
                index2--;
            }
            
            char tmp = nums[index1];
            nums[index1] = nums[index2];
            nums[index2] = tmp;
        }
        
        reverse(nums, index1+1, size-1);
    }
    
    private void reverse(char[] nums, int left, int right)
    {
        while (left < right)
        {
            char tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
            left++;
            right--;
        }
    }
	
    
    
    public int[] minInterval2(int[][] intervals, int[] queries) 
    {
        if (intervals == null || intervals.length == 0 || intervals[0].length != 2 || queries == null || queries.length == 0)
        {
            return new int[0];
        }
        
        TreeMap<Integer, TreeMap<Integer, PriorityQueue<Integer>>> treeMap = new TreeMap<>();
        
        for (int[] interval : intervals)
        {
        	if (!treeMap.containsKey(interval[0]))
        	{
        		treeMap.put(interval[0], new TreeMap<>());
        	}
        	
        	treeMap.get(interval[0]).computeIfAbsent(interval[1], x -> new PriorityQueue<>()).add(interval[1]-interval[0]+1);
        }
        
        int[] result = new int[queries.length];
        
        for (int i = 0; i < queries.length; i++)
        {
        	Map<Integer, TreeMap<Integer, PriorityQueue<Integer>>> map1 = treeMap.headMap(queries[i]+1);
        	
        	if (map1.size() == 0)
        	{
        		result[i] = -1;
        		continue;
        	}
        	
        	int candidiate = Integer.MAX_VALUE;
        	
        	for (Map.Entry<Integer, TreeMap<Integer, PriorityQueue<Integer>>> entry1 : map1.entrySet())
    		{
        		SortedMap<Integer, PriorityQueue<Integer>> map2 = entry1.getValue().tailMap(queries[i]);
    			
        		for (Map.Entry<Integer, PriorityQueue<Integer>> entry2 : map2.entrySet())
        		{
        			candidiate = Math.min(candidiate, entry2.getValue().peek());
        		}
    		}
        	
        	result[i] = candidiate == Integer.MAX_VALUE ? -1 : candidiate;
        }
        
        return result;
    }
    
	
    public int[] minInterval(int[][] intervals, int[] queries) 
    {
        if (intervals == null || intervals.length == 0 || intervals[0].length != 2 || queries == null || queries.length == 0)
        {
            return new int[0];
        }
        
        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));
        
        int[] tmpQueries = Arrays.copyOf(queries, queries.length);
        Arrays.sort(tmpQueries);
        
        Queue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0]-b[0]);
        Map<Integer, Integer> map = new HashMap<>();
        int[] result = new int[queries.length];
        int index = 0, size = intervals.length;
        
        for (int query : tmpQueries)
        {
        	while (index < size && intervals[index][0] <= query)
        	{
        		int left = intervals[index][0];
        		int right = intervals[index][1];
        		pq.offer(new int[] { right-left+1, right });
        		index++;
        	}
        	
        	while (!pq.isEmpty() && pq.peek()[1] < query)
        	{
        		pq.poll();
        	}
        	
        	map.put(query, pq.isEmpty() ? -1 : pq.peek()[0]);
        }
        
        for (int i = 0; i < queries.length; i++)
        {
        	result[i] = map.get(queries[i]);
        }
        
        return result;
    }
    
    
    
    public int maximumPopulation(int[][] logs) 
    {
        if (logs == null || logs.length == 0 || logs[0].length != 2)
        {
            return -1;
        }
        
        int curP = 0;
        int maxP = 0;
        int maxY = -1;
        
        Queue<Node> heap = new PriorityQueue<>((a, b) -> {
            if (a.year != b.year)
            {
                return a.year - b.year;
            }
            else if (a.isDeath)
            {
                return -1;
            }
            else if (b.isDeath)
            {
                return 1;
            }
            else
            {
                return 0;
            }
        });
        
        for (int[] log : logs)
        {
        	heap.offer(new Node(log[0], false));
        	heap.offer(new Node(log[1], true));
        }
        
        while (!heap.isEmpty())
        {
        	Node node = heap.poll();
        	
        	System.out.println("1 "+ node.year);
        	
            if (!node.isDeath)
            {
                curP++;
            }
            else
            {
                curP--;
            }
            
            while (!heap.isEmpty() && heap.peek().year == node.year)
            {
            	Node tmp = heap.poll();
            	
                if (!tmp.isDeath)
                {
                    curP++;
                }
                else
                {
                    curP--;
                }
            }
            
            System.out.println("2 "+ curP);
            
            if (curP > maxP)
            {
            	
            	
            	maxP = curP;
            	maxY = node.year;
            }
        }
        
        return maxY;
    }
    
    class Node
    {
        public int year;
        public boolean isDeath;
        
        public Node(int y, boolean d)
        {
            year = y;
            isDeath = d;
        }
    }
    
    
    public static void main(String[] args)
    {
    	Q000_A_Contest test = new Q000_A_Contest();
    	
    	/****************************************************/
 
    	int[][] logs1 = { {1993,1999},{2000,2010} };
    	int[][] logs2 = {{1950,1961},{1960,1971},{1970,1981}};
    	
    	System.out.println(test.maximumPopulation(logs1));
    	// System.out.println(test.maximumPopulation(logs2));
    	
    	
    }
}
