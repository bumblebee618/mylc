import java.math.BigDecimal;
import java.util.*;

import javax.management.relation.Role;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;







public class Q000_A_Contest 
{	  
	public int minTimeToType(String word) {
        char[] letters = word.toCharArray();
        int result = 0;
        char curPos = 'a';
        
        for (char letter : letters) {
        	int clockwise = (int) (letter - curPos) >= 0 ? (int) (letter - curPos) : (int) (letter - curPos) + 26;
        	int counterclockwise = (int) (curPos - letter) >= 0 ? (int) (curPos - letter) : (int) (curPos - letter) + 26;
            int distance = Math.min(clockwise, counterclockwise); 
            result += distance+1;
            curPos = letter;
        }
        
        return result;
    }
	

    
    public long maxMatrixSum(int[][] matrix) {
        int n = matrix.length;
        long sum = 0;
        int minPositive = Integer.MAX_VALUE;
        int maxNegative = Integer.MIN_VALUE;
        int negativeCount = 0;
        boolean hasZero = false;
        
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
            	sum += matrix[i][j] > 0 ? matrix[i][j] : -matrix[i][j];
            	
                if (matrix[i][j] > 0) {
                	minPositive = Math.min(minPositive, matrix[i][j]);
                } else if (matrix[i][j] < 0) {
                	maxNegative = Math.max(maxNegative, matrix[i][j]);
                	negativeCount++;
                } else {
					hasZero = true;
				}
            }
        }
        
        if (!hasZero && negativeCount % 2 > 0) {
        	if (minPositive != Integer.MAX_VALUE) {
        		sum -= 2 * Math.min(minPositive, -maxNegative);
        	} else {
        		sum += 2 * maxNegative;
        	}
        }
        
        return sum;
    }

    
    
    public int countPaths(int n, int[][] roads) {
        Map<Integer, Integer>[] graph = new Map[n];
        long[] count = new long[n], dist = new long[n];
        count[0] = 1;
        int mod = 1_000_000_007;
        
        for (int i = 0; i < n; i++) {
        	graph[i] = new HashMap<>();
        }
        
        for (int[] road : roads) {
        	graph[road[0]].put(road[1], road[2]);
        	graph[road[1]].put(road[0], road[2]);
        }
        
        Queue<Pair> pq = new PriorityQueue<>((a, b) -> a.distance - b.distance < 0 ? -1 : 1);
        pq.offer(new Pair(0, 0));
        
        while (!pq.isEmpty()) {
        	Pair pair = pq.poll();
        	
        	System.out.println(pair.node + ", " + pair.distance);
        	
        	if (dist[pair.node] < pair.distance) {
        		continue;
        	}
        	
        	for (int next : graph[pair.node].keySet()) {
        		if (pair.distance + graph[pair.node].get(next) < dist[next]) {
        			count[next] = count[pair.node] % mod;
        			dist[next] = pair.distance + graph[pair.node].get(next);
        			pq.offer(new Pair(next, dist[next]));
        		} else if (pair.distance + graph[pair.node].get(next) == dist[next]) {
        			count[next] = (count[next] + count[pair.node]) % mod;
        		}
        		
        	}
        }
        
        return (int) count[n-1];
    }
    
    class Pair {
    	public int node;
    	public long distance;
    	
    	public Pair (int n, long d) {
    		node = n;
    		distance = d;
    	}
    }
    
    
	
	
    public static void main(String[] args)
    {
    	Q000_A_Contest test = new Q000_A_Contest();
    	
    	/****************************************************/
    	
    	int[][] road1 = {{1,0,10}};
    	int[][] road2 = {{0,6,7},{0,1,2},{1,2,3},{1,3,3},{6,3,3},{3,5,1},{6,5,1},{2,5,1},{0,4,5},{4,6,2}};
  
    	System.out.println(test.countPaths(2, road1));
    }
}
