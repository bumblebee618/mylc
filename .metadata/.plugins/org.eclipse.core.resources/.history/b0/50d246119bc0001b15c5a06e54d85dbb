import java.util.HashMap;
import java.util.Map;

/***
 * 
 * @author jackie
 * 
 * You are given two integer arrays nums1 and nums2 of length n.

The XOR sum of the two integer arrays is (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) (0-indexed).

For example, the XOR sum of [1,2,3] and [3,2,1] is equal to (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4.
Rearrange the elements of nums2 such that the resulting XOR sum is minimized.

Return the XOR sum after the rearrangement.

 

Example 1:

Input: nums1 = [1,2], nums2 = [2,3]
Output: 2
Explanation: Rearrange nums2 so that it becomes [3,2].
The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.
Example 2:

Input: nums1 = [1,0,3], nums2 = [5,3,4]
Output: 8
Explanation: Rearrange nums2 so that it becomes [5,4,3]. 
The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.
 

Constraints:

n == nums1.length
n == nums2.length
1 <= n <= 14
0 <= nums1[i], nums2[i] <= 107
 */
public class Q1879_Minimum_XOR_Sum_of_Two_Arrays 
{
	// backtracking + memo search
	private HashMap<String, Integer> memo = new HashMap<>();
	
	public int minimumXORSum(int[] nums1, int[] nums2) 
	{
		if (nums1 == null || nums1.length == 0 || nums2 == null || nums1.length != nums2.length)
		{
			return 0;
		}
		
        int n = nums1.length;
        boolean[] status = new boolean[n];
        return search(nums1, nums2, 0, n, status);
    }
	
	private int search(int[] nums1, int[] nums2, int i, int n, boolean[] status) 
	{
        if (i == n) 
        {
        	return 0;
        }
        
        String curr = Integer.toString(i);
        
        for (int k = 0; k < n; k++)
        {
        	if (status[k]) 
        	{
        		curr += ";" + Integer.toString(k);
        	}
        }
        
        if (memo.containsKey(curr)) 
        {
        	return memo.get(curr);
        }
        
        int min = Integer.MAX_VALUE;
        
        for (int j = 0; j < n; j++) 
        {
            if (!status[j]) 
            {
                status[j] = true;
                min = Math.min(min, (nums1[i] ^ nums2[j]) + search(nums1, nums2, i + 1, n, status));
                status[j] = false;
            }
        }
        
        memo.put(curr, min);
        return min;
    } 
}
